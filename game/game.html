<!doctype html>
<html lang="en">
<head>
	<title>Maze Game</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel=stylesheet href="css/base.css"/>
</head>
<body>

<script src="js/three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>


<div id="ThreeJS" style="z-index: 1; position: absolute; left:0px; top:0px"></div>
<script>


// standard global variables
var container, scene, camera, renderer, controls;
//listens for key presses
var keyboard = new THREEx.KeyboardState();
//clock
var clock = new THREE.Clock();

// custom global variables
//previous direction for bounce
var lastDirection;
//if collided
var collision;
//player mesh
var player;
//array of all collidable objects
var collidableMeshList = [];
//if rotated
var rotatedFlag;

//2d array representing the maze
var maze = [
	[1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],//1
	[1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,1,1,1,1,1],//2
	[1,0,0,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1],//3
	[1,1,0,0,0,0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,1,1,1,1],//4
	[1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1],//5
	[1,1,1,1,1,0,1,0,0,0,0,0,0,1,1,0,0,0,1,1,1,1,1,1,1],//6
	[1,1,1,0,1,0,0,0,1,1,1,1,0,0,1,0,1,0,1,1,1,1,1,1,1],//7
	[1,1,1,0,1,1,1,1,1,1,1,1,1,0,1,0,1,0,0,0,1,1,1,1,1],//8
	[1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,1],//9
	[1,1,0,1,1,1,1,1,1,1,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1],//10
	[1,1,0,1,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,1,1,1,1,1,1],//11
	[1,1,0,0,0,1,1,0,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1],//12
	[1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,0,0,0,1,1,1],//13
	[1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,1],//14
	[1,1,1,0,0,0,1,0,0,0,1,1,1,1,1,0,1,1,0,1,1,0,1,1,1],//15
	[1,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,1,1,0,0,0,0,1,1,1],//16
	[1,0,1,1,1,1,1,1,0,1,1,0,0,0,0,0,1,1,1,1,1,0,1,1,1],//17
	[1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1],//18
	[1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,0,1,1,1],//19
	[1,0,0,0,1,1,0,1,1,1,0,1,1,1,1,1,1,1,0,0,0,0,1,1,1],//20
	[1,1,1,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,1,1,1,1],//21
	[1,1,1,1,1,1,1,1,0,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1],//22
	[1,1,1,1,1,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,1,1,1,1],//23
	[1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1],//24
	[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1]//25
];

// initialization
init();

// animation loop / game loop
animate();

function init()
{
	//initialize scene
	scene = new THREE.Scene();

	//set up camera

	// size according to window
	var SCREEN_WIDTH = window.innerWidth;
	var SCREEN_HEIGHT = window.innerHeight;
	// camera attributes
	var VIEW_ANGLE = 45;
	var ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT;
	var NEAR = 0.1;
	var FAR = 750;
	// set up camera
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	var light;  // A light shining from the direction of the camera; moves with the camera.
	light = new THREE.DirectionalLight();
	light.position.set(0,0,1);
	//add light to camera
	camera.add(light);
	// add the camera to the scene
	scene.add(camera);
	// the camera defaults to position (0,0,0)
	// 	so pull it back (z = 400) and up (y = 100) and set the angle towards the scene origin
	camera.position.set(0,150,400);
	camera.lookAt(scene.position);


	// initialize renderer use detector class to detect webgl compatibility if none use canvas renderer
	if ( Detector.webgl ){
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	}else{
		renderer = new THREE.CanvasRenderer();
	}
	//set size of viewport to render to
	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );

	// automatically resize renderer
	THREEx.WindowResize(renderer, camera);
	// toggle full-screen on given key press
	THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });


	//drag cursor to rotate, right click drag to pan and middle button to zoom
	controls = new THREE.OrbitControls( camera, renderer.domElement );


	// create a light
	var light = new THREE.PointLight(0xffffff);
	light.position.set(0,250,0);
	scene.add(light);
	var ambientLight = new THREE.AmbientLight(0x111111);
	scene.add(ambientLight);

	// Create an array of materials to be used in a player, one for each side
	var playerMaterialArray = [];
	// order to add materials: x+,x-,y+,y-,z+,z-



		playerMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0x000000, transparent: true, opacity: 0.5 } ) );
		playerMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0x000000, transparent: true, opacity: 0.5 } ) );
		playerMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0x000000, transparent: true, opacity: 0.5 } ) );
		playerMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0x000000, transparent: true, opacity: 0.5 } ) );
		playerMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0x000000, transparent: true, opacity: 0.5 } ) );
		playerMaterialArray.push( new THREE.MeshBasicMaterial( { color: 0x000000, transparent: true, opacity: 0.5 } ) );
		var playerMaterials = new THREE.MeshFaceMaterial( playerMaterialArray );
		//dims along with segments MORE SEGMENTS MEANS MORE RAYS AND LAGGIER GAME BECAUSE COLLISION
		var playerGeometry = new THREE.SphereGeometry( 10, 16, 16);
		player = new THREE.Mesh( playerGeometry, playerMaterials );
		player.position.set(-150, 40, 50);
		scene.add( player );

		// create a set of coordinate axes to help orient user
		//    specify length in pixels in each direction
		var axes = new THREE.AxisHelper(100);
		scene.add( axes );



	//maze

	//the basic block for our maze wall




	var crateTexture = new THREE.ImageUtils.loadTexture( 'images/crate.gif' );
	crateTexture.wrapS = THREE.MirroredRepeatWrapping;
	crateTexture.wrapT = THREE.MirroredRepeatWrapping;
	crateTexture.repeat.set( 70, 70);

	var testMaze = new THREE.Mesh(
		new THREE.CubeGeometry(100,150,100,4,4,4),
		//make the material reflective with a specular component
		new THREE.MeshPhongMaterial({
            color: 0x66BBFF,
            specular: 0x222222,
            shininess: 16,
            shading: THREE.FlatShading,
						map: crateTexture,
						side: THREE.DoubleSide
        })
	);


	for(var i = 0; i < maze.length; i++) {
    for(var j = 0; j < maze[i].length; j++) {
			if(maze[i][j] == 1){
					var test2 = testMaze.clone();
					test2.position.set(-2500+50+(j*100),75,-2500+50+(i*100));
					collidableMeshList.push(test2);
					scene.add(test2);
				}
    }
	}


	//dirt stage

	var dirtTexture = new THREE.ImageUtils.loadTexture( 'images/dirt-512.jpg' );
	dirtTexture.wrapS = THREE.MirroredRepeatWrapping;
	dirtTexture.wrapT = THREE.MirroredRepeatWrapping;
	dirtTexture.repeat.set( 70, 70);
	// render on both sides as we are on plane
	var dirtMaterial = new THREE.MeshBasicMaterial( { map: dirtTexture, side: THREE.DoubleSide } );
	var dirtGeometry = new THREE.PlaneGeometry(2500, 2500, 10, 10);
	var dirt = new THREE.Mesh(dirtGeometry, dirtMaterial);
	dirt.position.y = -1;
	//rotate else vertical
	dirt.position.x = -1250;
	dirt.position.z = -1250;
	dirt.rotation.x = Math.PI / 2;
	scene.add(dirt);

	//cubemap

	//path to image
	var path = "images/dawnmountain-";
	var type = '.png';
	var location = [
			path + 'xpos' + type,
			path + 'xneg' + type,
			path + 'ypos' + type,
			path + 'yneg' + type,
			path + 'zpos' + type,
			path + 'zneg' + type
		];

	//create textured cube
	var reflectionCube = new THREE.CubeTextureLoader().load( location );
	//set the scene background as out textured cube
	scene.background = reflectionCube;


	 //Just some variable initialization for collision detection
	 collision = false;
	 lastDirection = "up";
	 rotatedFlag = false
}

//animation loop function
function animate()
{
  requestAnimationFrame( animate );
	render();
	update();
}

function update()
{
	// delta = change in time since last call (in seconds)
	var delta = clock.getDelta(); // seconds.
	var moveDistance = 75 * delta; // 110 pixels per second
	var rotateAngle = Math.PI / 2 * delta;   // pi/2 radians (90 degrees) per second

	// local transformations

	if(!collision){

	//prevPosition.getPositionFromMatrix(player.matrixWorld);

        // rotate left or right
    var rotation_matrix = new THREE.Matrix4().identity();
    if ( keyboard.pressed("A") ) {
        player.rotateOnAxis(new THREE.Vector3(0, 1, 0), rotateAngle);
    }
    if ( keyboard.pressed("D") ) {
        player.rotateOnAxis(new THREE.Vector3(0, 1, 0), -rotateAngle);
    }



	if ( keyboard.pressed("left") ){
		if(rotatedFlag){
			player.rotation.x = 0;
			player.rotation.z = 0;
			rotatedFlag = false;
		}
		lastDirection = "left";
		player.translateX( -moveDistance );
	}
	else if ( keyboard.pressed("right") ){
		if(rotatedFlag){
			player.rotation.x = 0;
			player.rotation.z = 0;
			rotatedFlag = false;
		}
		player.translateX(  moveDistance );
		lastDirection = "right";
	}
	else if ( keyboard.pressed("W") ){
		if(rotatedFlag){
			player.rotation.x = 0;
			player.rotation.z = 0;
			rotatedFlag = false;
		}
		player.translateZ( -moveDistance );
		lastDirection = "W";
	}
	else if ( keyboard.pressed("S") ){
		if(rotatedFlag){
			player.rotation.x = 0;
			player.rotation.z = 0;
			rotatedFlag =false;
		}
		player.translateZ(  moveDistance );

		lastDirection = "S";
	}else if ( keyboard.pressed("up") ) {
		player.rotateOnAxis(new THREE.Vector3(1, 0, 0), rotateAngle);
		rotatedFlag = true;
	}
	else if ( keyboard.pressed("down") ) {
		player.rotateOnAxis(new THREE.Vector3(1, 0, 0), -rotateAngle);
		rotatedFlag = true
	}
	}else{

		if ( lastDirection == "left" )
            player.translateX(  moveDistance/1.2 );
		if ( lastDirection == "right" )
            player.translateX( -moveDistance/1.2 );
	  if ( lastDirection == "W" )
            player.translateZ( moveDistance/1.2 );
		else if ( lastDirection == "S" )
            player.translateZ( -moveDistance/1.2 );

		 collision = false;
	}

	//third person positioning
    var objectThirdPerson = new THREE.Vector3(0,0,45);

	//third person in world coordinates from player and the shift
    var worldThirdPerson = objectThirdPerson.applyMatrix4( player.matrixWorld );


    camera.position.x = worldThirdPerson.x;
    camera.position.y = worldThirdPerson.y;
    camera.position.z = worldThirdPerson.z;




	// collision detection:
	//   determines if any of the rays from the cube's origin to each vertex
	//		intersects any face of a mesh in the array of target meshes
	//   for increased collision accuracy, add more vertices to the cube;
	//		for example, new THREE.CubeGeometry( 64, 64, 64, 8, 8, 8, wireMaterial )
	//   HOWEVER: when the origin of the ray is within the target mesh, collisions do not occur
	var originPoint = player.position.clone();

	for (var vertexIndex = 0; vertexIndex < player.geometry.vertices.length; vertexIndex++)
	{
		var localVertex = player.geometry.vertices[vertexIndex].clone();
		var globalVertex = localVertex.applyMatrix4( player.matrix );
		var directionVector = globalVertex.sub( player.position );//from center to center of shape

		var ray = new THREE.Raycaster( originPoint, directionVector.clone().normalize(), 0, 75 );
		var collisionResults = ray.intersectObjects( collidableMeshList );
		if ( collisionResults.length > 0 && collisionResults[0].distance <= directionVector.length()+2){
			collision = true;
			break;
		}
	}

	controls.update();
}

function render()
{
    //place camera look at here because orbit controls over writes it
    camera.lookAt( player.position );
	renderer.render( scene, camera );
}

</script>

</body>
</html>
